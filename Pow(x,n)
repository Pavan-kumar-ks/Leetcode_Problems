class Solution {
    public double myPow(double x, int n) {
        long N = n;
        return N>=0 ? pow(x,N) :1.0/ pow(x,-N);
    }
       public double pow(double x, long N){
        if(N ==0){
            return 1.0;
        }
        double half = pow(x,N/2);
        if(N%2 == 0){
            return half*half;
        }
        else{
            return half*half*x;
        }
    }
}

Explanation:-
What happens on each recursive call?
Let’s say you're calling fastPow(2.0, 5). Here’s the breakdown:

🔹 Step 1: fastPow(2.0, 5)
n = 5, not zero → skip base case

Calls: half = fastPow(2.0, 2) ← wait here until fastPow(2.0, 2) returns

🔹 Step 2: fastPow(2.0, 2)
n = 2, not zero → skip base case

Calls: half = fastPow(2.0, 1)

🔹 Step 3: fastPow(2.0, 1)
n = 1, not zero → skip base case

Calls: half = fastPow(2.0, 0)

🔹 Step 4: fastPow(2.0, 0)
  Base case n == 0, return 1.0

🔄 Now let's return back up the tree:
🔼 Back to fastPow(2.0, 1)
half = 1.0

Since 1 is odd → go to else

Return 1.0 * 1.0 * 2.0 = 2.0

🔼 Back to fastPow(2.0, 2)
half = 2.0

Since 2 is even → go to if

Return 2.0 * 2.0 = 4.0

🔼 Back to fastPow(2.0, 5)
half = 4.0

Since 5 is odd → go to else

Return 4.0 * 4.0 * 2.0 = 32.0

