class Solution {
    public double myPow(double x, int n) {
        long N = n;
        return N>=0 ? pow(x,N) :1.0/ pow(x,-N);
    }
       public double pow(double x, long N){
        if(N ==0){
            return 1.0;
        }
        double half = pow(x,N/2);
        if(N%2 == 0){
            return half*half;
        }
        else{
            return half*half*x;
        }
    }
}

Explanation:-
What happens on each recursive call?
Letâ€™s say you're calling fastPow(2.0, 5). Hereâ€™s the breakdown:

ğŸ”¹ Step 1: fastPow(2.0, 5)
n = 5, not zero â†’ skip base case

Calls: half = fastPow(2.0, 2) â† wait here until fastPow(2.0, 2) returns

ğŸ”¹ Step 2: fastPow(2.0, 2)
n = 2, not zero â†’ skip base case

Calls: half = fastPow(2.0, 1)

ğŸ”¹ Step 3: fastPow(2.0, 1)
n = 1, not zero â†’ skip base case

Calls: half = fastPow(2.0, 0)

ğŸ”¹ Step 4: fastPow(2.0, 0)
  Base case n == 0, return 1.0

ğŸ”„ Now let's return back up the tree:
ğŸ”¼ Back to fastPow(2.0, 1)
half = 1.0

Since 1 is odd â†’ go to else

Return 1.0 * 1.0 * 2.0 = 2.0

ğŸ”¼ Back to fastPow(2.0, 2)
half = 2.0

Since 2 is even â†’ go to if

Return 2.0 * 2.0 = 4.0

ğŸ”¼ Back to fastPow(2.0, 5)
half = 4.0

Since 5 is odd â†’ go to else

Return 4.0 * 4.0 * 2.0 = 32.0

